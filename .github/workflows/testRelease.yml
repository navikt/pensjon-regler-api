name: Manual Release (Github Package Registry)

on: workflow_dispatch

jobs:
  release:
    permissions:
      contents: write
      packages: write
      deployments: write
    runs-on: ubuntu-latest

    steps:
      # Checkout the repository
      - uses: actions/checkout@v2

      # Get latest release tag
      - name: Get latest release tag
        id: get_latest_release
        run: |
          LATEST_TAG=$(curl -s \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/releases/latest" \
            | jq -r .tag_name)
          echo "Latest tag: $LATEST_TAG"
          echo "::set-output name=latest_tag::$LATEST_TAG"

      # Generate new version tag
      - name: Generate new version tag
        id: generate_new_tag
        run: |
          LATEST_TAG=${{ steps.get_latest_release.outputs.latest_tag }}
          if [[ $LATEST_TAG =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
            MAJOR=${BASH_REMATCH[1]}
            MINOR=${BASH_REMATCH[2]}
            PATCH=${BASH_REMATCH[3]}
            NEW_TAG="v$MAJOR.$MINOR.$((PATCH + 1))"
          else
            NEW_TAG="v1.0.0"
          fi
          echo "::set-output name=new_tag::$NEW_TAG"

      # Get commits since the latest release
      - name: Get commits since last release
        id: fetch_commits
        run: |
          COMMITS=$(curl -s \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/compare/${{ steps.get_latest_release.outputs.latest_tag }}...HEAD" \
            | jq -r '.commits[].commit.message' | sed 's/^/* /')
          echo "::set-output name=commits::$COMMITS"

      # Process commits and generate categorized release notes
      - name: Generate Release Notes
        id: generate_release_notes
        run: |
          COMMITS="${{ steps.fetch_commits.outputs.commits }}"

          # Categories
          NEW_FEATURES=$(echo "$COMMITS" | grep -i 'enhancement\|feature' | sed 's/^/* /')
          BUG_FIXES=$(echo "$COMMITS" | grep -i 'bug\|fix' | sed 's/^/* /')
          MAINTENANCE=$(echo "$COMMITS" | grep -i 'documentation\|refactor\|chore\|cleanup' | sed 's/^/* /')
          OTHER_CHANGES=$(echo "$COMMITS" | grep -v -i 'enhancement\|feature\|bug\|fix\|documentation\|refactor\|chore\|cleanup' | sed 's/^/* /')

          # Combine into final release notes with Markdown line breaks
          RELEASE_NOTES="## üöÄ New Features\n$NEW_FEATURES\n\n## üêõ Bug Fixes\n$BUG_FIXES\n\n## üßπ Maintenance\n$MAINTENANCE\n\n## üîÑ Uncategorized Changes\n$OTHER_CHANGES"

          # Replace \n with Markdown line breaks for GitHub formatting
          RELEASE_NOTES_MD=$(echo "$RELEASE_NOTES" | sed 's/\n/  \n/g')

          echo "::set-output name=release_notes::$RELEASE_NOTES_MD"

      # Create Release with Dynamic Release Notes
      - name: Create Release with Dynamic Release Notes
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ steps.generate_new_tag.outputs.new_tag }}
          name: ${{ steps.generate_new_tag.outputs.new_tag }}
          body: ${{ steps.generate_release_notes.outputs.release_notes }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Notify Slack about new release
      - name: Notify Slack about new release
        run: |
          SLACK_MESSAGE="*New Release: ${{ steps.generate_new_tag.outputs.new_tag }}*\n\nRelease Notes:\n${{ steps.generate_release_notes.outputs.release_notes }}"
          curl -X POST -H 'Content-type: application/json' \
            --data '{"text": "'"$SLACK_MESSAGE"'"}' \
            ${{ secrets.SLACK_WEBHOOK_URL }}
